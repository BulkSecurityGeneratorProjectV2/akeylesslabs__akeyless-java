/*
 * Akeyless API
 * The purpose of this application is to provide access to Akeyless API.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@akeyless.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.akeyless.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * RegexpTokenizerInfo represents a general Regexp tokenization template
 */
@ApiModel(description = "RegexpTokenizerInfo represents a general Regexp tokenization template")

public class RegexpTokenizerInfo {
  public static final String SERIALIZED_NAME_ALPHABET = "alphabet";
  @SerializedName(SERIALIZED_NAME_ALPHABET)
  private String alphabet;

  public static final String SERIALIZED_NAME_DECRYPTION_TEMPLATE = "decryption_template";
  @SerializedName(SERIALIZED_NAME_DECRYPTION_TEMPLATE)
  private String decryptionTemplate;

  public static final String SERIALIZED_NAME_ENCRYPTION_TEMPLATE = "encryption_template";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION_TEMPLATE)
  private String encryptionTemplate;

  public static final String SERIALIZED_NAME_PATTERN = "pattern";
  @SerializedName(SERIALIZED_NAME_PATTERN)
  private String pattern;


  public RegexpTokenizerInfo alphabet(String alphabet) {
    
    this.alphabet = alphabet;
    return this;
  }

   /**
   * The Alphabet used for the tokenization
   * @return alphabet
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The Alphabet used for the tokenization")

  public String getAlphabet() {
    return alphabet;
  }


  public void setAlphabet(String alphabet) {
    this.alphabet = alphabet;
  }


  public RegexpTokenizerInfo decryptionTemplate(String decryptionTemplate) {
    
    this.decryptionTemplate = decryptionTemplate;
    return this;
  }

   /**
   * Transformation to perform on the decrypted data
   * @return decryptionTemplate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Transformation to perform on the decrypted data")

  public String getDecryptionTemplate() {
    return decryptionTemplate;
  }


  public void setDecryptionTemplate(String decryptionTemplate) {
    this.decryptionTemplate = decryptionTemplate;
  }


  public RegexpTokenizerInfo encryptionTemplate(String encryptionTemplate) {
    
    this.encryptionTemplate = encryptionTemplate;
    return this;
  }

   /**
   * Transformation to perform on the encrypted data, if the required output template doesn&#39;t match the input string The output Should still be valid for the Pattern, otherwise the secret would be able to be decrypted.
   * @return encryptionTemplate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Transformation to perform on the encrypted data, if the required output template doesn't match the input string The output Should still be valid for the Pattern, otherwise the secret would be able to be decrypted.")

  public String getEncryptionTemplate() {
    return encryptionTemplate;
  }


  public void setEncryptionTemplate(String encryptionTemplate) {
    this.encryptionTemplate = encryptionTemplate;
  }


  public RegexpTokenizerInfo pattern(String pattern) {
    
    this.pattern = pattern;
    return this;
  }

   /**
   * Regexp pattern to extract and deposit the text/encdata
   * @return pattern
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Regexp pattern to extract and deposit the text/encdata")

  public String getPattern() {
    return pattern;
  }


  public void setPattern(String pattern) {
    this.pattern = pattern;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RegexpTokenizerInfo regexpTokenizerInfo = (RegexpTokenizerInfo) o;
    return Objects.equals(this.alphabet, regexpTokenizerInfo.alphabet) &&
        Objects.equals(this.decryptionTemplate, regexpTokenizerInfo.decryptionTemplate) &&
        Objects.equals(this.encryptionTemplate, regexpTokenizerInfo.encryptionTemplate) &&
        Objects.equals(this.pattern, regexpTokenizerInfo.pattern);
  }

  @Override
  public int hashCode() {
    return Objects.hash(alphabet, decryptionTemplate, encryptionTemplate, pattern);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RegexpTokenizerInfo {\n");
    sb.append("    alphabet: ").append(toIndentedString(alphabet)).append("\n");
    sb.append("    decryptionTemplate: ").append(toIndentedString(decryptionTemplate)).append("\n");
    sb.append("    encryptionTemplate: ").append(toIndentedString(encryptionTemplate)).append("\n");
    sb.append("    pattern: ").append(toIndentedString(pattern)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

